Q1) User's Third Transaction

Assume you are given the table below on Uber transactions made by users.
Write a query to obtain the third transaction of every user. Output the user id, spend and transaction date.

A1) Idea: The concept used to tackle these questions is Window Functions. There are 4 kinds of window functions:
(a) ROW_NUMBER() - Assigns a unique row number for each record
(b) RANK() - Assigns a rank depending on the partition and order
(c) DENSE_RANK() - Minor difference between RANK() and DENSE_RANK() --> If two values have the same rank, the rank assigned to the following item varies - Refer Source
(d) NTILE(N) 

Source: https://www.sqlshack.com/overview-of-sql-rank-functions/

'''CODE'''

WITH ranked_transactions AS(
SELECT *, RANK() OVER (PARTITION BY user_id Order by Transaction_date) as ranked_data
)

Select User_id, spend, transaction_date
From ranked_transactions
Where ranked_data = 3
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q2) Sending vs. Opening Snaps

Assume you are given the tables below containing information on Snapchat users, their ages, and their time spent sending and opening snaps. 
Write a query to obtain a breakdown of the time spent sending vs. opening snaps (as a percentage of total time spent on these activities) for each age group.

Output the age bucket and percentage of sending and opening snaps. Round the percentage to 2 decimal places.

''' CODE '''
Select AB.age_bucket, 
ROUND(100.0* 
    SUM(CASE WHEN AC.activity_type = 'send' THEN AC.time_spent ELSE 0 END)/
    (SUM(CASE WHEN AC.activity_type = 'open' THEN AC.time_spent ELSE 0 END) + SUM(CASE WHEN AC.activity_type = 'send' THEN AC.time_spent ELSE 0 END)),2) as send_perc,
ROUND(100.0* 
    SUM(CASE WHEN AC.activity_type = 'open' THEN AC.time_spent ELSE 0 END)/
    (SUM(CASE WHEN AC.activity_type = 'open' THEN AC.time_spent ELSE 0 END) + SUM(CASE WHEN AC.activity_type = 'send' THEN AC.time_spent ELSE 0 END)),2) as open_perc
FROM age_breakdown AB
JOIN activities AC 
ON AB.user_id = AC.user_id
Group BY AB.age_bucket
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q3) Highest-Grossing Items
Assume you are given the table containing information on Amazon customers and their spending on products in various categories.
Identify the top two highest-grossing products within each category in 2022. Output the category, product, and total spend.

Link: https://datalemur.com/questions/sql-highest-grossing

A3) Idea: Need to group by Product and Sum(Spend) then RANK over Category and order by total_spend
- Clear in idea but implemented about 70% of the solution
- Logic was to use 2 CTE

''' CODE ''
WITH Product_total_spend AS(
  SELECT CATEGORY, PRODUCT, SUM(Spend) as total_spend
  FROM product_spend
  WHERE Transaction_date between '01/01/2022' and '12/31/2022'
  GROUP BY CATEGORY, PRODUCT
  ORDER BY total_spend DESC), 
  
RANKED_TOP_SPEND AS(
  SELECT *, RANK() OVER(PARTITION BY CATEGORY ORDER BY TOTAL_SPEND DESC) as ranking
  FROM Product_total_spend
)

SELECT CATEGORY, PRODUCT, total_spend
FROM RANKED_TOP_SPEND
WHERE ranking<=2
ORDER BY Category, ranking

* When it feels like you need to RANK OVER A GROUP BY OPERATION, USE 2 CTEs
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q4) Top 5 Artists

Assume there are three Spotify tables containing information about the artists, songs, and music charts. 
Write a query to determine the top 5 artists whose songs appear in the Top 10 of the global_song_rank table the highest number of times. From now on, we'll refer to this ranking number as "song appearances".

Output the top 5 artist names in ascending order along with their song appearances ranking (not the number of song appearances,
but the rank of who has the most appearances). The order of the rank should take precedence.

A4) ''' CODE '''
WITH artist_rank_info AS(
    Select songs.artist_id, gsr.song_id, Count(gsr.song_id) as song_appearance
    FROM global_song_rank gsr
    JOIN songs
    ON gsr.song_id = songs.song_id
    WHERE gsr.rank between 1 and 10
    GROUP BY songs.artist_id,gsr.song_id
    Order by song_appearance DESC
),
artist_appearances AS(
SELECT artist_id, SUM(song_appearance) as TOTAL_RANKS
FROM artist_rank_info
GROUP BY artist_id
ORDER BY TOTAL_RANKS DESC
),
final_output AS(
SELECT artists.artist_name, DENSE_RANK() OVER(ORDER BY AA.total_ranks DESC) as ARTIST_RANK
FROM artist_appearances AA
JOIN artists
ON AA.artist_id = artists.artist_id
ORDER BY ARTIST_RANK, artists.artist_name
)

SELECT artist_name, ARTIST_RANK
FROM final_output
WHERE ARTIST_RANK<=5

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q5) Supercloud Customer 
A Microsoft Azure Supercloud customer is a company which buys at least 1 product from each product category.
Write a query to report the company ID which is a Supercloud customer.
Link: https://datalemur.com/questions/supercloud-customer

A5) Idea: Find the sum of product category and check that the sum >=1 for each

'''CODE'''
With customer_count AS
(
    SELECT CC.customer_id, 
    SUM(CASE WHEN p.product_category = 'Analytics' THEN 1 ELSE 0 END) AS Analytics_count,
    SUM(CASE WHEN p.product_category = 'Containers' THEN 1 ELSE 0 END) AS Containers_count,
    SUM(CASE WHEN p.product_category = 'Compute' THEN 1 ELSE 0 END) AS Compute_count
    FROM customer_contracts CC
    JOIN products p
    ON CC.product_id = p.product_id
    GROUP BY CC.customer_id
)

SELECT customer_id 
FROM customer_count
WHERE Analytics_count >=1 and Containers_count>=1 and Compute_count>=1

* Above approach is wrong as number of product_categories are not known

''' Updated Code'''
Select CC.customer_id
FROM customer_contracts CC
JOIN products P
ON 
CC.product_id = P.product_id
WHERE P.Product_Category IN (
    select Distinct(Product_Category) as distinct_prod_categories
    FROM products
)
Group by CC.customer_id
HAVING Count(DISTINCT(P.Product_category))  >= 3
ORDER BY Count(DISTINCT(P.Product_category)) DESC, CC.customer_id DESC
